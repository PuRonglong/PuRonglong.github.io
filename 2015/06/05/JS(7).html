<!DOCTYPE html>
<html>

	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>蒲荣龙的博客</title>
	<meta name="description" content="5.5.5 函数属性和方法">

	<link rel="stylesheet" href="/css/bootstrap.css">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/code.css">
	<link rel="canonical" href="http://www.puronglong.com/2015/06/05/JS(7).html">
	<link rel="alternate" type="application/rss+xml" title="小龙龙的个人博客" href="http://www.puronglong.com/feed.xml">
</head>


	<body>

		<div class="pull-right right-sidebar">
	<p>标签：</p>
	
	<p>
	<a class="page-link" href="/tag/技术">技术</a>
	<span>（66）</span></p>
	
	<p>
	<a class="page-link" href="/tag/生活">生活</a>
	<span>（37）</span></p>
	
</div>
		
		<div class="pull-left left-sidebar">
			<ul class="header-list">
				<li><a class="page-link" href="/">Home</a></li>
				<li><a class="page-link" href="/about/">About</a></li>
				<li><a class="page-link" href="/feed.xml">RSS</a></li>
			</ul>
		</div>
		<div class="page-content">
			<div class="wrapper">
				<article class="post home" itemscope itemtype="http://schema.org/BlogPosting">

	<header class="post-header">
		<h1 class="post-title" itemprop="name headline">JS:引用类型(二)</h1>
		<p class="post-meta">2015-06-05</p>
	</header>

	<div class="post-content" itemprop="articleBody">
		<h3 id="section">5.5.5 函数属性和方法</h3>

<p>前面曾经提到过，ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数也都包含两个属性：length和prototype。其中，length属性表示函数希望接收的参数的个数，也可能为0.</p>

<p>在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。在ES5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>

<!-- more -->

<p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。</p>

<p>首先，apply()方法接收两个参数:一个是在其中运行函数的作用域，另一个是参数数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kd">function</span> <span class="nx">callSum1</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span><span class="c1">//传入arguments对象</span>
	<span class="p">}</span>

	<span class="kd">function</span> <span class="nx">callSum2</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,[</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">]);</span><span class="c1">//传入数组</span>
	<span class="p">}</span>

	<span class="nx">alert</span><span class="p">(</span><span class="nx">callSum1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span><span class="c1">//20</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">callSum2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span><span class="c1">//20</span>
</code></pre>
</div>

<p>由以上代码可知，第二个参数可以是Array的实例，也可以是arguments对象。</p>

<p>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下所示：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">num1</span> <span class="o">+</span> <span class="nx">num2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kd">function</span> <span class="nx">callSum</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">sum</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nx">alert</span><span class="p">(</span><span class="nx">callSum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span><span class="c1">//20</span>
</code></pre>
</div>

<p>事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域</p>

<p>使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</p>

<p>ECMAScript5还定义了一个方法:bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="nb">window</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
	    <span class="na">color</span><span class="p">:</span><span class="s2">"blue"</span>
	<span class="p">};</span>

	<span class="kd">function</span> <span class="nx">sayColor</span><span class="p">(){</span>
	    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">objectSayColor</span> <span class="o">=</span> <span class="nx">sayColor</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
	<span class="nx">objectSayColor</span><span class="p">();</span><span class="c1">//blue</span>
</code></pre>
</div>

<p>在这里，sayColor()调用bind()并传入对象o,创建了objectSayColor()函数。objectSayColor函数的this值等于o，因此即使是在全局作用域中调用这个函数，也会看到”blue”。</p>

<p>IE8并不支持bind()</p>

<h2 id="section-1">5.6 基本包装类型</h2>

<p>为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型:Boolean,Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="s2">"some text"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">s1</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre>
</div>

<p>其实，为了让我们事先这种直观的操作，后台已经自动完成了一系列的处理。经过此番处理，基本的字符串值就变得跟对象一样了。</p>

<p>引用类型与基本包装类型的主要区别就是<strong>对象的生存期</strong>。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这以为着我们不能再运行时为基本类型值添加属性和方法。来看下面的例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="s2">"some text"</span><span class="p">;</span>
	<span class="nx">s1</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="s2">"red"</span><span class="p">;</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">s1</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span><span class="c1">//undefined</span>
</code></pre>
</div>

<p>问题的原因就是第二行创建的String对象在执行第三行代码时已经被销毁了。第三行代码又创建了自己的String对象，而该对象没有color属性。</p>

<p>对基本包装类型的实例调用typeof会返回”object”,而且所有基本包装类型的对象都会被转换为布尔值true。</p>

<p>Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>

<p>要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="s2">"25"</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">number</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="c1">//转型函数</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">number</span><span class="p">);</span><span class="c1">//"number"</span>

	<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span><span class="c1">//构造函数</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span><span class="p">);</span><span class="c1">//"object"</span>
</code></pre>
</div>

<p>在这个例子中，变量number中宝尊的是基本类型的值25,而变量obj中保存的是Number的实例。</p>

<h3 id="boolean">5.6.1 Boolean类型</h3>

<p>Boolean类型是与布尔值对应的引用类型。Boolean类型的实例重写了valueOf()和toString()方法，返回基本类型值true或false；</p>

<p>最常见的问题是在布尔表达式中使用Boolean对象。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">falseObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">falseObject</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="c1">//true</span>

	<span class="kd">var</span> <span class="nx">falseValue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
	<span class="nx">result</span> <span class="o">=</span> <span class="nx">falseValue</span> <span class="o">&amp;&amp;</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="c1">//false</span>
</code></pre>
</div>

<p>在这个例子中，我们使用false值创建一个Boolean对象。然后，将这个对象与基本类型值true构成了逻辑与表达式。在布尔运算中，false &amp;&amp; true 等于false。可是，示例中的这行代码是对falseObject而不是对它的值(false)进行求值。前面讨论过，<strong>布尔表达式中的所有对象都会被转换为true</strong>，因此falseObject对象在布尔表达式中代表的是true。结果便是true了。</p>

<p>基本类型与引用类型的布尔值还有两个区别。首先typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">falseObject</span><span class="p">);</span><span class="c1">//object</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">falseValue</span><span class="p">);</span><span class="c1">//boolean</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">falseObject</span> <span class="k">instanceof</span> <span class="nb">Boolean</span><span class="p">);</span><span class="c1">//true</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">falseValue</span> <span class="k">instanceof</span> <span class="nb">Boolean</span><span class="p">);</span><span class="c1">//false</span>
</code></pre>
</div>

<p>由于Boolean对象是Boolean类型的实例所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>

<p>理解基本类型的布尔值与Boolean对象之间的区别非常重要——当然，我们的建议是永远不要使用Boolean对象</p>

<h3 id="number-">5.6.2 Number 类型</h3>

<p>Number是与数字值对应的引用类型。</p>

<p>可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p>

<p>Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示。</p>

<p>如果数值本身包含的小数位比指定还多，那么接近指定的最大小数位的值就会舍入，而这个自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。</p>

<p>另外一个可用于格式化数值的方法是toExponential()，该方法返回以指数表示法表示的数值的字符串形式。</p>

<p>对一个数值来说，toPrecision()方法可能会返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式最合适。</p>

<p>与此同时，我们仍然不建议直接实例化Number类型，语言与显示创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kd">var</span> <span class="nx">numberOject</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="kd">var</span> <span class="nx">numberValue</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">numberOject</span><span class="p">);</span><span class="c1">//object</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">numberValue</span><span class="p">);</span><span class="c1">//number</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">numberOject</span> <span class="k">instanceof</span> <span class="nb">Number</span><span class="p">);</span><span class="c1">//true</span>
	<span class="nx">alert</span><span class="p">(</span><span class="nx">numberValue</span> <span class="k">instanceof</span> <span class="nb">Number</span><span class="p">);</span><span class="c1">//false</span>
</code></pre>
</div>

<p>instanceof用来判断一个变量是否是某个对象的实例。类似地，Number对象时Number类型的实例，而基本类型的数值则不是。</p>

<h3 id="string">5.6.3 String类型</h3>

<p>String类型是字符串的对象包装类型。String类型的每个实例都有一个length属性，表示字符串中包含多个字符。应该注意的是，即使字符串中包含双字节字符，每个字符仍然算一个字符。</p>

<p>1.字符方法</p>

<p>两个用于访问字符串中特定字符的方法是：charAt()和charCodeAt()。其中charAt()方法以单字符串的形式返回给定位置的那个字符。如果你想得到的不是字符而是字符编码，那么就要使用charCodeAt()了。</p>

<p>2.字符串操作方法</p>

<p>下面介绍与操作字符串有关的几个方法。第一个就是concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。</p>

<p>虽然concat()是专门用来拼接字符串的方法，但时间中使用更多的还是加号操作符(+)。而且使用加号操作符在大多数啊情况下都比使用concat()方法要简便易行。</p>

<p>ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()，substr()和substring()。与concat()方法一样，这三个方法返回一个基本类型的字符串值。</p>

<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。</p>

<p>3.字符串位置方法</p>

<p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置(如果没有找到，则返回-1)。</p>

<p>4.trim()方法</p>

<p>ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>

<p>由于trim()返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。IE8不支持</p>

<p>5.字符串大小写转换写法</p>

<p>ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase(),toLocaleLowerCase(),toUpperCase()和toLocaleUpperCase()。</p>

<p>6.字符串的模式匹配方法</p>

<p>String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()方法只接受一个参数，要么是正则表达式，要么是一个RegExp对象。</p>

<p>另一个用于查找模式的方法是search()。此方法返回字符串中第一个匹配项的索引</p>

<p>为了简化替换子字符串的操作，ECMAScript提供了replace()方法</p>

<p>最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>

<p>对split()中正则表达式的支持因浏览器而异。</p>

<p>7.localeCompare()方法</p>

<p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个子字符串，并返回结果值。</p>

<p>8.fromCharCode()方法</p>

<p>另外，String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。</p>

<p>9.HTML方法</p>

<p>早期的Web浏览器提供商觉察到了使用JavaScript动态格式化HTML的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见HTML格式化任务的方法。不过，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。</p>

<h2 id="section-2">5.7 单体内置对象</h2>

<p>ECMA-262对内置对象的定义是：“由ECMAScript实现提供的，不依赖与宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”例如Object,Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。</p>

<h3 id="global">5.7.1 Global对象</h3>

<p>Global(全局)对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。Global对象还包含一些其他方法。</p>

<p>1.URI编码方法</p>

<p>Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器。前者主要用于整个URI，而后者主要用于对URI中的某一段进行编码。</p>

<p>它们的主要区别在于，前者不会对本身属于URI的特殊字符进行编码，例如冒号，正斜杠，问号和井字号；而后者则会对它发现的额任何非标准字符进行编码。</p>

<p>与上面两个方法对应的还有两个解码方法。</p>

<p>2.eval()方法</p>

<p>现在，我们介绍最后一个——大概也是整个ECMAScript语言中最强大的饿一个方法:eval()。eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JS)字符串。</p>

<p>能够解释代码字符串的能力非常强大，但也非常危险。因此在使用eval()时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码(即所谓的代码注入).</p>

<p>3.Global对象的属性</p>

<p>Global对象还包含一些属性，例如，特殊的值undefined,NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，想Object和Function，也都是Global对象的属性。</p>

<p>ES5明确禁止给undefined,Nan和Infinity赋值</p>

<p>4.window对象</p>

<p>ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</p>

<h3 id="math">5.7.2 Math对象</h3>

<p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。Math对象提供的计算功能执行起来要快得多。</p>

<p>1.Math对象的属性</p>

<p>比如Math.PI</p>

<p>2.min()和max()方法</p>

<p>可接受任意多参数，可使用apply()方法</p>

<p>3.舍入方法</p>

<p>有三个，Math.ceil(),Math.floor()和Math.round()</p>

<p>4.random()方法</p>

<p>可从数组中随机取出字符串</p>

<p>5.其他方法</p>

<p>比如Math.sqrt(num),不同实现可能会对这些方法采用不同的算法，所以，这些方法在不同的实现中可能会有不同的精度。</p>

<h2 id="section-3">5.8 小结</h2>

	</div>

</article>

			</div>
		</div>

		<a href="#" class="to-top">Top</a>

		<footer class="site-footer">

	<div class="wrapper">

		<div class="footer-col-wrapper">

			<div>
				<ul class="social-media-list">
					
					<li>
						<a href="https://github.com/puronglong"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">puronglong</span></a>

					</li>
					
				</ul>
			</div>

		</div>

	</div>

</footer>

<script type="text/javascript" src='/js/jquery.min.js'></script>

<script type="text/javascript">

	var a = "\n                                   _                                         \n _ __  _   _ _ __ ___  _ __   __ _| | ___  _ __   __ _   ___  __ _ _   _   _ \n| '_ \\| | | | '__/ _ \\| '_ \\ / _` | |/ _ \\| '_ \\ / _` | / __|/ _` | | | | (_)\n| |_) | |_| | | | (_) | | | | (_| | | (_) | | | | (_| | \\__ \\ (_| | |_| |  _ \n| .__/ \\__,_|_|  \\___/|_| |_|\\__, |_|\\___/|_| |_|\\__, | |___/\\__,_|\\__, | (_)\n|_|                          |___/               |___/             |___/     \n          _                                                                  \n  /\\  /\\ (_)                                                                 \n / /_/ / | |                                                                 \n/ __  /  | |                                                                 \n\\/ /_/   |_|            😃";
    console.info(a);

	document.addEventListener('visibilitychange', function() {
                document.title = document.hidden ? '崩溃了，来看一下':'小龙龙的个人博客~'
            });
</script>
<script type="text/javascript">
	var offsetTop = 300;
	var to_top_arrow = $('.to-top');
	$(window).scroll(function(){
		
		($(this).scrollTop() > offsetTop) ? to_top_arrow.addClass('to-top-arrow') : to_top_arrow.removeClass('to-top-arrow');
	});

	to_top_arrow.on('click', function(event){
		event.preventDefault();
		$('body,html').animate({
			scrollTop: 0,
			
		});
	});
</script>


	</body>

</html>
