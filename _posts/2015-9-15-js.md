---
layout: post
title: JS(8):JS中对象和继承
description: "JS"
tags: [技术,Javascript]
image:
background: triangular.png
comments: true
share: true
---

## 第六章 面向对象的程序设计

本章内容：

* 理解对象属性
* 理解并创建对象
* 理解继承

面向对象的语言有一个标志，那就是它们都有**类**的概念，而通过类可以创建任意多个具有相同属性和方法的对象。

<!--more-->

ECMA-262把对象定义为：“**无序属性的集合，其属性可以包含基本值，对象或者函数。**”

## 6.1 理解对象

创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。

几年后，对象字面量成为创建这种对象的首选模式。

### 6.1.1 属性类型

ECMAScript中有两种属性：**数据属性**和**访问器属性**

1.数据属性

数据属性包含一个数据值的位置

要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。用得比较少

2.访问器属性

访问器属性不包含数据值；它们包含一对儿getter和setter函数，不过这两个函数都不是必需的。

### 6.1.2 定义多个属性

ES5定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性

### 6.1.3 读取属性的特性

使用ES5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符(比如是否是可配置的，可写的等)。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。

JS中可以针对任何对象——包括DOM和BOM对象，使用这个方法。

## 6.2 创建对象

### 6.2.1 工厂模式

一种设计模式，抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)

### 6.2.2 构造函数模式

构造函数可用来创建特定类型的对象，与前一个模式相比，可以不显式地创建对象；可以直接将属性和方法赋给this对象；没有return 语句

按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他的OO语言，主要是为了区别于ECMAScript中的其他函数

要调用Person的新实例，必须使用new操作符。

instanceof用于检测对象类型

创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，而这正式构造函数模式胜过工厂模式的地方。

1.将构造函数当做函数：构造函数与其他函数的唯一区别，就在于调用它们的方式不同。任何函数只要通过new操作符来调用，那它就可以作为构造函数。代码里展示了三种调用方式。

2.构造函数的问题：每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。每个Person实例都包含一个不同的Function实例(以显示name属性)。可以通过把函数定义转移到构造函数外部来解决这个问题。

问题：在全局作用域中定义的函数实际上只能别某个对象调用，名不副实。定义很多个全局函数，我们这个自定义的引用类型就丝毫没有封装性可言了。

### 6.2.3 原型模式

原型属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法

与构造函数不同的是，新对象的这些属性和方法是由所有实例共享的。

1.理解原型对象

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索从对象实例本身开始

这正是多个对象实例共享原型所保存的属性和方法的基本原理。

不能通过对象实例重写原型中的值。不过，使用delete操作符可以完全删除实例属性。

hasOwnProperty()方法只在给定属性存在于对象实例中时，才会返回true

2.原型与in操作符

有两种方式使用in操作符：单独使用和在for-in循环中使用

3.更简单的原型语法

为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象
