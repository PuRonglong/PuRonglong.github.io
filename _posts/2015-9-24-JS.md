---
layout: post
title: JS(9):函数表达式
description: "JS"
tags: [技术,Javascript]
image:
background: triangular.png
comments: true
share: true
---

本章内容：

* 函数表达式的特征
* 使用函数实现递归
* 使用闭包定义私有变量

函数表达式是 JavaScript 中的一个既强大又容易令人困惑的特性。定义函数的 方式有两种:一种是函数声明,另一种就是函数表达式。

<!--more-->

关于函数声明,它的一个重要特征就是**函数声明提升**(function declaration hoisting),意思是在执行 代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。

{% highlight JavaScript %}
sayHi();
function sayHi(){
    alert("Hi!");
}
{% endhighlight %}

第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式

{% highlight JavaScript %}
var functionName = function(arg0, arg1, arg2){ //函数体
};
{% endhighlight %}

这种形式看起来好像是常规的变量赋值语句,即创建一个函数并将它赋值给变量 functionName。 这种情况下创建的函数叫做匿名函数(anonymous function),因为 function 关键字后面没有标识符。

匿名函数有时候也叫拉姆达函数。

理解函数提升的关键,就是理解函数声明与函数表达式之间的区别。


## 7.1 递归

递归函数是在一个函数通过名字调用自身的情况下构成的，

{% highlight JavaScript %}
function factorial(num){
    if (num <= 1){
￼￼  return 1;
} else { 
￼   return num * factorial(num-1);
    }
}
{% endhighlight %}

这是一个**经典的递归阶乘函数**。虽然这个函数表面看来没什么问题,但下面的代码却可能导致它出错。

{% highlight JavaScript %}
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)); //出错
{% endhighlight %}

在接下来调用 `anotherFactorial()时`,由于必须执行 factorial(),而 factorial 已经不再是函数,所以就会导致错误

在这种情况下,使用`argu- ments.callee`可以解决这个问题。我们知道,arguments.callee是一个指向***正在执行的函数的指针***,因此可以用它来实现对函数的递归调用,

五种基本类型：**Undefied,Null,Number,Boolean,String**

引用类型：```Object / Array / Function / Date / RegExp / Error / Map / Set``` …

{% highlight JavaScript %}

{% endhighlight %}

## 闭包

有不少开发人员总是搞不清匿名函数和闭包这两个概念,因此经常混用。闭包是指有权访问另一个 函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数。

一般来讲, 当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,闭包的情况又有所不同。

在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。

解除对匿名函数的引用(以便释放内存)<br  />
compareNames = null;

由于闭包会携带包含它的函数的作用域,因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多,我们建议读者只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存,但请大家还是要慎重使用闭包

看来关于内存泄露的问题，以后要谈谈

### 7.2.1 闭包与变量

作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最 后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。下面这个例子可以清晰地说 明这个问题。

{% highlight JavaScript %}
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(){
			return i; };
		}
    return result;
}
{% endhighlight %}

因为每个函数的作用域链中都保存着createFunctions()函数的活动对象,所以它们引用的都是同一个变量i。当 createFunctions()函数返回后,变量i的值是10,此时每个函数都引用着保存变量i的同一个变量 对象,所以在每个函数内部 i的值都是10。但是,我们可以通过创建另一个匿名函数强制让闭包的行为符合预期,如下所示。

{% highlight JavaScript %}
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(num){
            return function(){
				return num;
    	return result;
	}
{% endhighlight %}

定义了一个匿名函数,并将立即执行该匿名函数的结果赋给数组

这样一来,result数组中的每个函数都有自己num变量的一个副本,因此就可以返回各自不同的数值了

### 7.2.2 关于this对象
