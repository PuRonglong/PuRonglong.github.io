<!DOCTYPE html>
<html>

	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>蒲荣龙的博客</title>
	<meta name="description" content="第七章：JS函数表达式">

	<link rel="stylesheet" href="/css/bootstrap.css">
	<link rel="stylesheet" href="/css/main.css">
	<link rel="stylesheet" href="/css/code.css">
	<link rel="canonical" href="http://localhost:4000/2015/09/24/JS.html">
	<link rel="alternate" type="application/rss+xml" title="blog" href="http://localhost:4000/feed.xml">
</head>


	<body>

		<div class="pull-right right-sidebar">
	<p>标签：</p>
	
	<p>
	<a class="page-link" href="/tag/技术">技术</a>
	<span>（64）</span></p>
	
	<p>
	<a class="page-link" href="/tag/生活">生活</a>
	<span>（35）</span></p>
	
</div>
		
		<div class="pull-left left-sidebar">
			<ul class="header-list">
				<li><a class="page-link" href="/">Home</a></li>
				<li><a class="page-link" href="/about/">About</a></li>
				<li><a class="page-link" href="/feed.xml">RSS</a></li>
			</ul>
		</div>
		<div class="page-content">
			<div class="wrapper">
				<article class="post home" itemscope itemtype="http://schema.org/BlogPosting">

	<header class="post-header">
		<h1 class="post-title" itemprop="name headline">JS(9):函数表达式</h1>
		<p class="post-meta">2015-09-24</p>
	</header>

	<div class="post-content" itemprop="articleBody">
		<h2 id="js">第七章：JS函数表达式</h2>

<p>本章内容：</p>

<ul>
  <li>函数表达式的特征</li>
  <li>使用函数实现递归</li>
  <li>使用闭包定义私有变量</li>
</ul>

<p>函数表达式是 JavaScript 中的一个既强大又容易令人困惑的特性。定义函数的 方式有两种:一种是函数声明,另一种就是函数表达式。</p>

<!-- more -->

<p>关于函数声明,它的一个重要特征就是<strong>函数声明提升</strong>(function declaration hoisting),意思是在执行 代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="nx">sayHi</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">sayHi</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">"Hi!"</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">functionName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg0</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">){</span> <span class="c1">//函数体</span>
    <span class="p">};</span>
</code></pre>
</div>

<p>这种形式看起来好像是常规的变量赋值语句,即创建一个函数并将它赋值给变量 functionName。 这种情况下创建的函数叫做匿名函数(anonymous function),因为 function 关键字后面没有标识符。</p>

<p>匿名函数有时候也叫拉姆达函数。</p>

<p>理解函数提升的关键,就是理解函数声明与函数表达式之间的区别。</p>

<h2 id="section">7.1 递归</h2>

<p>递归函数是在一个函数通过名字调用自身的情况下构成的，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">num</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">){</span>
    <span class="err">￼￼</span>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
    <span class="err">￼</span>   <span class="k">return</span> <span class="nx">num</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">num</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>这是一个<strong>经典的递归阶乘函数</strong>。虽然这个函数表面看来没什么问题,但下面的代码却可能导致它出错。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">anotherFactorial</span> <span class="o">=</span> <span class="nx">factorial</span><span class="p">;</span>
    <span class="nx">factorial</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">anotherFactorial</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="c1">//出错</span>
</code></pre>
</div>

<p>在接下来调用 <code class="highlighter-rouge">anotherFactorial()时</code>,由于必须执行 factorial(),而 factorial 已经不再是函数,所以就会导致错误</p>

<p>在这种情况下,使用<code class="highlighter-rouge">argu- ments.callee</code>可以解决这个问题。我们知道,arguments.callee是一个指向<strong><em>正在执行的函数的指针</em></strong>,因此可以用它来实现对函数的递归调用,</p>

<p>五种基本类型：<strong>Undefied,Null,Number,Boolean,String</strong></p>

<p>引用类型：<code class="highlighter-rouge">Object / Array / Function / Date / RegExp / Error / Map / Set</code> …</p>

<h2 id="section-1">闭包</h2>

<p>有不少开发人员总是搞不清匿名函数和闭包这两个概念,因此经常混用。闭包是指有权访问另一个 函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数。</p>

<p>一般来讲, 当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,闭包的情况又有所不同。</p>

<p>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。</p>

<p>解除对匿名函数的引用(以便释放内存)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="nx">compareNames</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre>
</div>

<p>由于闭包会携带包含它的函数的作用域,因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多,我们建议读者只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存,但请大家还是要慎重使用闭包</p>

<p>看来关于内存泄露的问题，以后要谈谈</p>

<h3 id="section-2">7.2.1 闭包与变量</h3>

<p>作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最 后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。下面这个例子可以清晰地说 明这个问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">createFunctions</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    			<span class="k">return</span> <span class="nx">i</span><span class="p">;</span> <span class="p">};</span>
    		<span class="p">}</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>因为每个函数的作用域链中都保存着createFunctions()函数的活动对象,所以它们引用的都是同一个变量i。当 createFunctions()函数返回后,变量i的值是10,此时每个函数都引用着保存变量i的同一个变量 对象,所以在每个函数内部 i的值都是10。但是,我们可以通过创建另一个匿名函数强制让闭包的行为符合预期,如下所示。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function createFunctions(){
    var result = new Array();
    for (var i=0; i &lt; 10; i++){
        result[i] = function(num){
            return function(){
    			return num;
    	return result;
    }
</code></pre>
</div>

<p>定义了一个匿名函数,并将立即执行该匿名函数的结果赋给数组</p>

<p>这样一来,result数组中的每个函数都有自己num变量的一个副本,因此就可以返回各自不同的数值了</p>

<h3 id="this">7.2.2 关于this对象</h3>

<p>this 对象是在运行时基于函数的执 行环境绑定的:在全局函数中,this 等于 window,而当函数被作为某个对象的方法调用时,this 等 于那个对象。不过,匿名函数的执行环境具有全局性,因此其 this 对象通常指向 window1。但有时候 由于编写闭包的方式不同,这一点可能不会那么明显。如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"The Window"</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">name</span> <span class="p">:</span> <span class="s2">"My Object"</span><span class="p">,</span>
        <span class="na">getNameFunc</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getNameFunc</span><span class="p">()());</span> <span class="c1">//"The Window"(在非严格模式下)</span>
</code></pre>
</div>

<p>为什么匿名函数没 有取得其包含作用域(或外部作用域)的 this 对象呢?</p>

<p>前面曾经提到过,每个函数在被调用时都会自动取得两个特殊变量:this和arguments。内部函数在搜索这两个变量时,只会搜索到其活动对象为止,因此永远不可能直接访问外部函数中的这两个变量。</p>

<p>不过,把外部作用域中的 this 对象保存在一个闭包能够访问 到的变量里,就可以让闭包访问该对象了,如下所示。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"The Window"</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">name</span> <span class="p">:</span> <span class="s2">"My Object"</span><span class="p">,</span>
            <span class="na">getNameFunc</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
            <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
        <span class="p">};</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getNameFunc</span><span class="p">()());</span>  <span class="c1">//"My Object"</span>
</code></pre>
</div>

<p>代码中突出的行展示了这个例子与前一个例子之间的不同之处。在定义匿名函数之前,我们把this对象赋值给了一个名叫that 的变量。而在定义了闭包之后,闭包也可以访问这个变量,因为它是我们在包含函数中特意声名的一个变量。即使在函数返回之后,that也仍然引用着object,所以调用object.getNameFunc()()就返回了”My Object”。</p>

<p>this和arguments也存在同样的问题。如果想访问作用域中的arguments对象,必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p>

<h3 id="section-3">7.2.3 内存泄漏</h3>

<p>由于 IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程(第4章曾经讨论过),因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说,如果闭包的作用域链中保存着一个HTML元素,那么就意味着该元素将无法被销毁。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">assignHandler</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"someElement"</span><span class="p">);</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="nx">alert</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
            <span class="p">};</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>以上代码创建了一个作为 element 元素事件处理程序的闭包,而这个闭包则又创建了一个循环引 用(事件将在第 13 章讨论)。由于匿名函数保存了一个对 assignHandler()的活动对象的引用,因此 就会导致无法减少 element 的引用数。只要匿名函数存在,element 的引用数至少也是 1,因此它所 占用的内存就永远不会被回收。不过,这个问题可以通过稍微改写一下代码来解决,如下所示。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">assignHandler</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"someElement"</span><span class="p">);</span> <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
            <span class="nx">element</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
    <span class="p">};</span>
            <span class="nx">element</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>在上面的代码中,通过把element.id的一个副本保存在一个变量中,并且在闭包中引用该变量<strong>消除了循环引用</strong>。但仅仅做到这一步,还是不能解决内存泄漏的问题。必须要记住:<strong>闭包会引用包含函数的整个活动对象</strong>,而其中包含着element。即使闭包不直接引用element,包含函数的活动对象中也仍然会保存一个引用。因此,有必要把element变量设置为null。这样就能够解除对DOM对象的引用,顺利地减少其引用数,确保正常回收其占用的内存。</p>

<h2 id="section-4">7.3 模仿块级作用域</h2>

<p>如前所述,JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量,实际上是在包含
函数中而非语句中创建的,来看下面的例子。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">outputNumbers</span><span class="p">(</span><span class="nx">count</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="p">}</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">//计数 </span>
    <span class="p">}</span>
</code></pre>
</div>

<p>个函数中定义了一个 for 循环,而变量 i 的初始值被设置为 0。在 Java、C++等语言中,变量 i 只会在 for 循环的语句块中有定义,循环一旦结束,变量 i 就会被销毁。可是在 JavaScrip 中,变量 i 是定义在 ouputNumbers()的活动对象中的,因此从它有定义开始,就可以在函数内部随处访问它。</p>

<p>匿名函数可以用来<strong><em>模仿</em></strong>块级作用域并避免这个问题。用作块级作用域(通常称为私有作用域)的匿名函数的语法如下所示。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="p">(</span><span class="kd">function</span><span class="p">(){</span> 
    <span class="c1">//这里是块级作用域</span>
    <span class="p">})();</span>
</code></pre>
</div>

<p>将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。一对圆括号将函数声明转换成函数表达式。</p>

<p>无论在什么时候，只要临时需要一些变量，就可以使用私有作用域。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">outputNumbers</span><span class="p">(</span><span class="nx">count</span><span class="p">){</span>
        <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
                <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})();</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">//􏰠􏰡􏰢􏰣􏰤􏰥􏰦 导致一个错误！</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</p>

<p>这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p>

<h2 id="section-5">7.4 私有变量</h2>

<p>严格来讲，Javascript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数，局部变量和在函数内部定义的其他函数。</p>

<p>如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。</p>

<p>我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method)。</p>

<p>有两种在对象 上创建特权方法的方式。第一种是在构造函数中定义特权方法,基本模式如下。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">MyObject</span><span class="p">(){</span>
       <span class="c1">//私有变量和私有函数 </span>
        <span class="kd">var</span> <span class="nx">privateVariable</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kd">function</span> <span class="nx">privateFunction</span><span class="p">(){</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//特权方法</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
            <span class="nx">privateVariable</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">privateFunction</span><span class="p">();</span>
        <span class="p">};</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>不过,在构造函数中定义特权方法也有一个缺点,那就是你必须使用构造函数模式来达到这个目的。</p>

<p>曾经讨论过,构造函数模式的缺点是针对每个实例都会创建同样一组新方法,而使用静态私有变量来实现特权方法就可以避免这个问题。</p>

<h3 id="section-6">7.4.1 静态私有变量</h3>

<p>通过在私有作用域中定义私有变量或函数,同样也可以创建特权方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//私有变量和私有函数</span>
    <span class="kd">var</span> <span class="nx">privateVariable</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="kd">function</span> <span class="nx">privateFunction</span><span class="p">(){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//构造函数</span>
    <span class="nx">MyObject</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="p">};</span>
    <span class="c1">//公有/特权方法</span>
    <span class="nx">MyObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="nx">privateVariable</span><span class="o">++</span><span class="p">;</span>
                <span class="k">return</span> <span class="nx">privateFunction</span><span class="p">();</span>
            <span class="p">};</span>
    <span class="p">})();</span>
</code></pre>
</div>

<p>需要注意的是,这个模式在定义构造函数时并没有使用函数声明,而是 使用了函数表达式。函数声明只能创建局部函数,但那并不是我们想要的。出于同样的原因,我们也没 有在声明 MyObject 时使用 var 关键字。记住:初始化未经声明的变量,总是会创建一个全局变量。 因此,MyObject 就成了一个全局变量,能够在私有作用域之外被访问到。但也要知道,在严格模式下给未经声明的变量赋值会导致错误。</p>

<p>这个模式与在构造函数中定义特权方法的主要区别,就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的,因此所有实例都使用同一个函数。而这个特权方法,作为一个闭包,总是保存着对包含作用域的引用。来看一看下面的代码。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
            <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">""</span><span class="p">;</span>
            <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
                <span class="nx">name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">};</span>
            <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="k">return</span> <span class="nx">name</span><span class="p">;</span>
            <span class="p">};</span>
            <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">){</span>
            <span class="nx">name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">})();</span>
    <span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">"Nicholas"</span><span class="p">);</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Nicholas" person1.setName("Greg"); alert(person1.getName()); //"Greg"</span>
    <span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">"Michael"</span><span class="p">);</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Michael"</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">person2</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">//"Michael"</span>
</code></pre>
</div>

<p>以这种方式创建静态私有变量会因为使用原型而增进代码复用,但每个实例都没有自己的私有变量。到底是使用实例变量,还是静态私有变量,最终还是要视你的具体需求而定。</p>

<p>查找作用域链中的一个层次,就会在一定程度上影响查找速度。而这正是使用 闭包和私有变量的一个显明的不足之处。</p>

<h3 id="section-7">7.4.2 模块模式</h3>

<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强,其语法形式如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">singleton</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">//私有变量和私有函数</span>
    <span class="kd">var</span> <span class="nx">privateVariable</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
            <span class="kd">function</span> <span class="nx">privateFunction</span><span class="p">(){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span><span class="c1">//特权/公有方法和属性</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="na">publicProperty</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
                <span class="na">publicMethod</span> <span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
                    <span class="nx">privateVariable</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nx">privateFunction</span><span class="p">();</span>
                <span class="p">}</span>
    <span class="p">};</span> <span class="p">}();</span>
</code></pre>
</div>

<h3 id="section-8">7.4.3 增强的模块模式</h3>

<p>有人进一步改进了模块模式,即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那 些单例必须是某种类型的实例,同时还必须添加某些属性和(或)方法对其加以增强的情况。</p>

<h2 id="section-9">7.5 小结</h2>

	</div>

</article>

			</div>
		</div>

		<footer class="site-footer">

	<div class="wrapper">

		<div class="footer-col-wrapper">

			<div>
				<ul class="social-media-list">
					
					<li>
						<a href="https://github.com/puronglong"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">puronglong</span></a>

					</li>
					
				</ul>
			</div>

		</div>

	</div>

</footer>

<script type="text/javascript">

	var a = "\n                                   _                                         \n _ __  _   _ _ __ ___  _ __   __ _| | ___  _ __   __ _   ___  __ _ _   _   _ \n| '_ \\| | | | '__/ _ \\| '_ \\ / _` | |/ _ \\| '_ \\ / _` | / __|/ _` | | | | (_)\n| |_) | |_| | | | (_) | | | | (_| | | (_) | | | | (_| | \\__ \\ (_| | |_| |  _ \n| .__/ \\__,_|_|  \\___/|_| |_|\\__, |_|\\___/|_| |_|\\__, | |___/\\__,_|\\__, | (_)\n|_|                          |___/               |___/             |___/     \n          _                                                                  \n  /\\  /\\ (_)                                                                 \n / /_/ / | |                                                                 \n/ __  /  | |                                                                 \n\\/ /_/   |_|            😃";
    console.info(a);

	document.addEventListener('visibilitychange', function() {
                document.title = document.hidden ? '崩溃了，来看一下':'小龙龙的个人博客~'
            });
</script>


	</body>

</html>
